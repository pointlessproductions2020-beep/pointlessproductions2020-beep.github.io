<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PointlessPhotoEditor</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      background: #121212;
      color: #fff;
      overflow: hidden;
    }

    header {
      padding: 1rem;
      font-size: 1.8rem;
      font-weight: bold;
      letter-spacing: 1px;
      color: #00ffd0;
      text-align: center;
      background: #1f1f1f;
      border-bottom: 1px solid #333;
    }

    #editorContainer {
      display: flex;
      width: 100%;
      height: calc(100vh - 70px);
    }

    #leftToolbar {
      width: 80px;
      background: #1f1f1f;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1rem 0;
      gap: 1rem;
      border-right: 1px solid #333;
    }

    #leftToolbar .tool-icon {
      font-size: 24px;
      color: #aaa;
      cursor: pointer;
      transition: color 0.2s, transform 0.2s;
    }

    #leftToolbar .tool-icon:hover {
      color: #fff;
      transform: scale(1.2);
    }

    #leftToolbar .tool-icon.active {
      color: #00ffd0;
      transform: scale(1.3);
    }

    #mainEditor {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #121212;
      padding: 1rem;
      position: relative;
    }

    canvas {
      border: 1px solid #444;
      background: #fff;
    }

    #textInput {
      position: absolute;
      display: none;
      background: transparent;
      border: none;
      color: #000;
      font-size: 20px;
      font-family: inherit;
      outline: none;
      z-index: 10;
    }

    #cropBox {
      position: absolute;
      border: 2px dashed #00ffd0;
      pointer-events: none;
      display: none;
      z-index: 9;
    }

    #paletteDisplay {
      margin-top: 1rem;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .swatch {
      width: 30px;
      height: 30px;
      border: 1px solid #444;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .swatch:hover {
      transform: scale(1.1);
    }

    #leftToolbar input[type="file"],
    #leftToolbar button {
      width: 60px;
      font-size: 12px;
      background: #333;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 0.3rem;
      cursor: pointer;
      text-align: center;
    }

    #leftToolbar button:hover {
      background: #444;
    }
  </style>
</head>
<body>
  <header>ðŸŽ¨ PointlessPhotoEditor</header>

  <div id="editorContainer">
    <div id="leftToolbar">
      <i class="bi bi-brush tool-icon active" data-tool="brush" title="Brush"></i>
      <i class="bi bi-eraser tool-icon" data-tool="eraser" title="Eraser"></i>
      <i class="bi bi-fonts tool-icon" data-tool="text" title="Text"></i>
      <i class="bi bi-paint-bucket tool-icon" data-tool="bucket" title="Paint Bucket"></i>
      <i class="bi bi-scissors tool-icon" data-tool="crop" title="Crop Tool"></i>
      <i class="bi bi-arrows-move tool-icon" data-tool="move" title="Move Tool"></i>
      <i class="bi bi-magic tool-icon" data-tool="select" title="Magic Select"></i>
      <input type="file" id="upload" accept="image/*" title="Upload Image" />
      <button onclick="saveImage()">ðŸ’¾</button>
      <button onclick="clearCanvas()">ðŸ§¹</button>
    </div>

    <div id="mainEditor">
      <canvas id="editorCanvas" width="900" height="600"></canvas>
      <input type="text" id="textInput" />
      <div id="cropBox"></div>
      <div id="paletteDisplay"></div>
    </div>
  </div>
//SECTION 1 OVER//
<script>
const canvas = document.getElementById('editorCanvas');
const ctx = canvas.getContext('2d');
const textInput = document.getElementById('textInput');
const cropBox = document.getElementById('cropBox');
let drawing = false;
let color = '#000000';
let brushSize = 4;
let toolMode = 'brush';
let textX = 0, textY = 0;
let lastX = 0, lastY = 0;
let cropStart = null;

// Tool switching
document.querySelectorAll('.tool-icon').forEach(icon => {
  icon.addEventListener('click', () => {
    document.querySelectorAll('.tool-icon').forEach(i => i.classList.remove('active'));
    icon.classList.add('active');
    toolMode = icon.getAttribute('data-tool');
  });
});

// Drawing logic
canvas.addEventListener('mousedown', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  if (toolMode === 'text') {
    textX = x;
    textY = y;
    textInput.style.left = `${x}px`;
    textInput.style.top = `${y}px`;
    textInput.style.display = 'block';
    textInput.value = '';
    textInput.focus();
  } else if (toolMode === 'bucket') {
    floodFill(x, y, color);
  } else if (toolMode === 'crop') {
    cropStart = { x, y };
    cropBox.style.left = `${x}px`;
    cropBox.style.top = `${y}px`;
    cropBox.style.width = '0px';
    cropBox.style.height = '0px';
    cropBox.style.display = 'block';
  } else {
    drawing = true;
    [lastX, lastY] = [x, y];
  }
});

canvas.addEventListener('mousemove', (e) => {
  if (!drawing || toolMode === 'text' || toolMode === 'bucket') return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  if (toolMode === 'crop' && cropStart) {
    cropBox.style.width = `${Math.abs(x - cropStart.x)}px`;
    cropBox.style.height = `${Math.abs(y - cropStart.y)}px`;
  } else {
    ctx.strokeStyle = toolMode === 'eraser' ? '#ffffff' : color;
    ctx.lineWidth = brushSize;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(x, y);
    ctx.stroke();
    [lastX, lastY] = [x, y];
  }
});

canvas.addEventListener('mouseup', () => drawing = false);
canvas.addEventListener('mouseleave', () => drawing = false);

// Upload image
document.getElementById('upload').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const img = new Image();
  img.onload = () => ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  img.src = URL.createObjectURL(file);
});

// Clear canvas
function clearCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
}

// Save image
function saveImage() {
  const link = document.createElement('a');
  link.download = 'pointless-edit.png';
  link.href = canvas.toDataURL();
  link.click();
}
  // TEXT TOOL 2.0
textInput.addEventListener('blur', () => {
  const text = textInput.value.trim();
  if (text) {
    ctx.fillStyle = color;
    ctx.font = '20px Segoe UI';
    ctx.textBaseline = 'top';
    ctx.fillText(text, textX, textY);
  }
  textInput.style.display = 'none';
});

textInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    textInput.blur();
  }
});
  // CROP TOOL 2.0
window.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && toolMode === 'crop' && cropStart) {
    const rect = cropBox.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();
    const x = rect.left - canvasRect.left;
    const y = rect.top - canvasRect.top;
    const w = rect.width;
    const h = rect.height;

    const imageData = ctx.getImageData(x, y, w, h);

    // Resize canvas and redraw cropped area
    canvas.width = w;
    canvas.height = h;
    ctx.putImageData(imageData, 0, 0);

    cropBox.style.display = 'none';
    cropStart = null;
  }
});
  // BUCKET TOOL 2.0
function floodFill(x, y, fillColor) {
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const pixels = imageData.data;
  const width = canvas.width;
  const height = canvas.height;

  const stack = [[x, y]];
  const targetColor = getPixelColor(pixels, x, y, width);
  const fill = hexToRgb(fillColor);

  if (colorsMatch(targetColor, fill)) return;

  while (stack.length) {
    const [px, py] = stack.pop();
    const currentColor = getPixelColor(pixels, px, py, width);
    if (!colorsMatch(currentColor, targetColor)) continue;

    setPixelColor(pixels, px, py, width, fill);

    stack.push([px + 1, py], [px - 1, py], [px, py + 1], [px, py - 1]);
  }

  ctx.putImageData(imageData, 0, 0);
}

function getPixelColor(pixels, x, y, width) {
  const i = (y * width + x) * 4;
  return [pixels[i], pixels[i + 1], pixels[i + 2]];
}

function setPixelColor(pixels, x, y, width, color) {
  const i = (y * width + x) * 4;
  pixels[i] = color[0];
  pixels[i + 1] = color[1];
  pixels[i + 2] = color[2];
  pixels[i + 3] = 255;
}

function colorsMatch(a, b) {
  return Math.abs(a[0] - b[0]) < 32 &&
         Math.abs(a[1] - b[1]) < 32 &&
         Math.abs(a[2] - b[2]) < 32;
}

function hexToRgb(hex) {
  return [
    parseInt(hex.slice(1, 3), 16),
    parseInt(hex.slice(3, 5), 16),
    parseInt(hex.slice(5, 7), 16)
  ];
}
  // PALETTE GENERATOR + COLOR PICKER
function generatePalette() {
  const baseHex = '#ff6600'; // You can make this dynamic later
  const palette = getPalette(baseHex);
  const display = document.getElementById('paletteDisplay');
  display.innerHTML = '';
  palette.forEach(hex => {
    const swatch = document.createElement('div');
    swatch.className = 'swatch';
    swatch.style.background = hex;
    swatch.title = hex;
    swatch.onclick = () => {
      color = hex;
    };
    display.appendChild(swatch);
  });
}

function getPalette(baseHex) {
  const r = parseInt(baseHex.slice(1, 3), 16);
  const g = parseInt(baseHex.slice(3, 5), 16);
  const b = parseInt(baseHex.slice(5, 7), 16);
  const comp = rgbToHex(255 - r, 255 - g, 255 - b);
  const triad1 = shiftHue(baseHex, 120);
  const triad2 = shiftHue(baseHex, 240);
  return [baseHex, comp, triad1, triad2];
}

function rgbToHex(r, g, b) {
  return "#" + [r, g, b].map(x => {
    const hex = x.toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  }).join('');
}

function shiftHue(hex, degree) {
  let r = parseInt(hex.slice(1, 3), 16) / 255;
  let g = parseInt(hex.slice(3, 5), 16) / 255;
  let b = parseInt(hex.slice(5, 7), 16) / 255;
  let max = Math.max(r, g, b), min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;

  if (max === min) {
    h = s = 0;
  } else {
    let d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }

  h = (h * 360 + degree) % 360;
  if (h < 0) h += 360;
  return hslToHex(h, s, l);
}

function hslToHex(h, s, l) {
  h /= 360;
  let r, g, b;

  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    };

    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }

  return rgbToHex(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255));
}
  // LAYER SYSTEM 2.0
class Layer {
  constructor(name, width, height) {
    this.name = name;
    this.canvas = document.createElement('canvas');
    this.canvas.width = width;
    this.canvas.height = height;
    this.ctx = this.canvas.getContext('2d');
    this.visible = true;
    this.opacity = 1;
    this.blendMode = 'source-over';
  }

  renderTo(baseCtx) {
    if (this.visible) {
      baseCtx.globalAlpha = this.opacity;
      baseCtx.globalCompositeOperation = this.blendMode;
      baseCtx.drawImage(this.canvas, 0, 0);
    }
  }
}

const layers = [new Layer('Background', canvas.width, canvas.height)];
let activeLayer = layers[0];

function renderAllLayers() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  layers.forEach(layer => layer.renderTo(ctx));
}

// Override drawing to use activeLayer
canvas.addEventListener('mousedown', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  if (toolMode === 'text') {
    textX = x;
    textY = y;
    textInput.style.left = `${e.clientX}px`;
    textInput.style.top = `${e.clientY}px`;
    textInput.style.display = 'block';
    textInput.value = '';
    textInput.focus();
  } else if (toolMode === 'bucket') {
    floodFill(x, y, color);
    renderAllLayers();
  } else if (toolMode === 'crop') {
    cropStart = { x, y };
    cropBox.style.left = `${e.clientX}px`;
    cropBox.style.top = `${e.clientY}px`;
    cropBox.style.width = '0px';
    cropBox.style.height = '0px';
    cropBox.style.display = 'block';
  } else {
    drawing = true;
    [lastX, lastY] = [x, y];
  }
});

canvas.addEventListener('mousemove', (e) => {
  if (!drawing || toolMode === 'text' || toolMode === 'bucket') return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  if (toolMode === 'crop' && cropStart) {
    cropBox.style.width = `${Math.abs(x - cropStart.x)}px`;
    cropBox.style.height = `${Math.abs(y - cropStart.y)}px`;
  } else {
    const ctxLayer = activeLayer.ctx;
    ctxLayer.strokeStyle = toolMode === 'eraser' ? '#ffffff' : color;
    ctxLayer.lineWidth = brushSize;
    ctxLayer.lineCap = 'round';
    ctxLayer.beginPath();
    ctxLayer.moveTo(lastX, lastY);
    ctxLayer.lineTo(x, y);
    ctxLayer.stroke();
    [lastX, lastY] = [x, y];
    renderAllLayers();
  }
});

canvas.addEventListener('mouseup', () => drawing = false);
canvas.addEventListener('mouseleave', () => drawing = false);
  // FILTER ENGINE 2.0
const filters = {
  grayscale: ([r, g, b]) => {
    const avg = (r + g + b) / 3;
    return [avg, avg, avg];
  },
  invert: ([r, g, b]) => [255 - r, 255 - g, 255 - b],
  sepia: ([r, g, b]) => [
    r * 0.393 + g * 0.769 + b * 0.189,
    r * 0.349 + g * 0.686 + b * 0.168,
    r * 0.272 + g * 0.534 + b * 0.131
  ]
};

function applyFilter(filterName) {
  const imageData = activeLayer.ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;
  const fn = filters[filterName];

  for (let i = 0; i < data.length; i += 4) {
    const [r, g, b] = fn([data[i], data[i + 1], data[i + 2]]);
    data[i] = r;
    data[i + 1] = g;
    data[i + 2] = b;
  }

  activeLayer.ctx.putImageData(imageData, 0, 0);
  renderAllLayers();
}
  // FINAL POLISH 2.0

// Keyboard shortcuts
window.addEventListener('keydown', (e) => {
  if (e.ctrlKey || e.metaKey) return; // skip system shortcuts

  switch (e.key.toLowerCase()) {
    case 'b': toolMode = 'brush'; break;
    case 'e': toolMode = 'eraser'; break;
    case 't': toolMode = 'text'; break;
    case 'c': toolMode = 'crop'; break;
    case 'm': toolMode = 'move'; break;
    case 's': toolMode = 'select'; break;
    case 'f': applyFilter('sepia'); break;
    case 'g': applyFilter('grayscale'); break;
    case 'i': applyFilter('invert'); break;
  }

  document.querySelectorAll('.tool-icon').forEach(i => {
    i.classList.toggle('active', i.getAttribute('data-tool') === toolMode);
  });
});

// Brush size control (optional slider)
const brushSlider = document.createElement('input');
brushSlider.type = 'range';
brushSlider.min = 1;
brushSlider.max = 20;
brushSlider.value = 4;
brushSlider.style.width = '60px';
brushSlider.title = 'Brush Size';
brushSlider.oninput = () => {
  brushSize = parseInt(brushSlider.value);
};
document.getElementById('leftToolbar').appendChild(brushSlider);

// Initial palette
generatePalette();

// Welcome log
console.log('%cPointlessPhotoEditor loaded. Go make something ridiculous.', 'color:#00ffd0;font-weight:bold;font-size:14px');
  
</script>
 

  
  

  
