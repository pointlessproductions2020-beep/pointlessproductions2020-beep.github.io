<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PointlessPhotoEditor</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      background: #121212;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    header {
      padding: 1rem;
      font-size: 1.8rem;
      font-weight: bold;
      letter-spacing: 1px;
      color: #00ffd0;
    }

    #toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      justify-content: center;
      align-items: center;
      background: #1f1f1f;
      padding: 1rem;
      border-bottom: 1px solid #333;
      width: 100%;
    }

    .tool-icon {
      font-size: 24px;
      color: #aaa;
      cursor: pointer;
      transition: color 0.2s, transform 0.2s;
    }

    .tool-icon:hover {
      color: #fff;
      transform: scale(1.2);
    }

    .tool-icon.active {
      color: #00ffd0;
      transform: scale(1.3);
    }

    button, input[type="color"], input[type="range"], input[type="number"] {
      padding: 0.5rem;
      border: none;
      border-radius: 4px;
      background: #333;
      color: #fff;
      cursor: pointer;
    }

    #colorPreview {
      width: 30px;
      height: 30px;
      border: 2px solid #fff;
      background-color: #000;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 0 5px #00ffd0;
    }

    canvas {
      border: 1px solid #444;
      background: #fff;
      margin-top: 1rem;
      position: relative;
    }

    #paletteDisplay {
      margin-top: 1rem;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .swatch {
      width: 30px;
      height: 30px;
      border: 1px solid #444;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .swatch:hover {
      transform: scale(1.1);
    }

    #textInput {
      position: absolute;
      display: none;
      background: transparent;
      border: none;
      color: #000;
      font-size: 20px;
      font-family: inherit;
      outline: none;
      z-index: 10;
    }

    #cropBox {
      position: absolute;
      border: 2px dashed #00ffd0;
      pointer-events: none;
      display: none;
      z-index: 9;
    }
  </style>
</head>
<body>
  <header>ðŸŽ¨ PointlessPhotoEditor</header>

  <div id="toolbar">
    <i class="bi bi-brush tool-icon active" data-tool="brush" title="Brush"></i>
    <i class="bi bi-eraser tool-icon" data-tool="eraser" title="Eraser"></i>
    <i class="bi bi-fonts tool-icon" data-tool="text" title="Text"></i>
    <i class="bi bi-paint-bucket tool-icon" data-tool="bucket" title="Paint Bucket"></i>
    <i class="bi bi-scissors tool-icon" data-tool="crop" title="Crop Tool"></i>
    <input type="file" id="upload" accept="image/*" />
    <input type="color" id="colorPicker" value="#000000" />
    <div id="colorPreview" title="Current Brush Color"></div>
    <input type="range" id="brushSize" min="1" max="20" value="4" />
    <input type="number" id="canvasWidth" value="900" min="100" style="width: 70px;" />
    <input type="number" id="canvasHeight" value="600" min="100" style="width: 70px;" />
    <button onclick="resizeCanvas()">Resize</button>
    <button onclick="clearCanvas()">Clear</button>
    <button onclick="saveImage()">Save</button>
    <input type="color" id="baseColor" value="#ff6600" />
    <button onclick="generatePalette()">ðŸŽ¨ Palette</button>
  </div>

  <canvas id="editorCanvas" width="900" height="600"></canvas>
<input type="text" id="textInput" />
<div id="cropBox"></div>
<div id="paletteDisplay"></div>

<script>
  const canvas = document.getElementById('editorCanvas');
  const ctx = canvas.getContext('2d');
  const textInput = document.getElementById('textInput');
  const cropBox = document.getElementById('cropBox');
  let drawing = false;
  let color = '#000000';
  let brushSize = 4;
  let toolMode = 'brush';
  let textX = 0, textY = 0;
  let lastX = 0, lastY = 0;
  let cropStart = null;

  // Tool switching
  document.querySelectorAll('.tool-icon').forEach(icon => {
    icon.addEventListener('click', () => {
      document.querySelectorAll('.tool-icon').forEach(i => i.classList.remove('active'));
      icon.classList.add('active');
      toolMode = icon.getAttribute('data-tool');
    });
  });

  // Drawing logic
  canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (toolMode === 'text') {
      textX = x;
      textY = y;
      textInput.style.left = `${e.clientX}px`;
      textInput.style.top = `${e.clientY}px`;
      textInput.style.display = 'block';
      textInput.value = '';
      textInput.focus();
    } else if (toolMode === 'bucket') {
      floodFill(x, y, color);
    } else if (toolMode === 'crop') {
      cropStart = { x, y };
      cropBox.style.left = `${e.clientX}px`;
      cropBox.style.top = `${e.clientY}px`;
      cropBox.style.width = '0px';
      cropBox.style.height = '0px';
      cropBox.style.display = 'block';
    } else {
      drawing = true;
      [lastX, lastY] = [x, y];
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!drawing || toolMode === 'text' || toolMode === 'bucket') return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (toolMode === 'crop' && cropStart) {
      cropBox.style.width = `${Math.abs(e.clientX - cropBox.offsetLeft)}px`;
      cropBox.style.height = `${Math.abs(e.clientY - cropBox.offsetTop)}px`;
    } else {
      ctx.strokeStyle = toolMode === 'eraser' ? '#ffffff' : color;
      ctx.lineWidth = brushSize;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(x, y);
      ctx.stroke();
      [lastX, lastY] = [x, y];
    }
  });

  canvas.addEventListener('mouseup', () => drawing = false);
  canvas.addEventListener('mouseleave', () => drawing = false);

  // Confirm crop on Enter
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && toolMode === 'crop' && cropStart) {
      const rect = cropBox.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      const x = rect.left - canvasRect.left;
      const y = rect.top - canvasRect.top;
      const w = rect.width;
      const h = rect.height;

      const imageData = ctx.getImageData(x, y, w, h);
      canvas.width = w;
      canvas.height = h;
      ctx.putImageData(imageData, 0, 0);
      cropBox.style.display = 'none';
      cropStart = null;
    }
  });

  // Text input blur
  textInput.addEventListener('blur', () => {
    const text = textInput.value;
    if (text) {
      ctx.fillStyle = color;
      ctx.font = '20px Segoe UI';
      ctx.fillText(text, textX, textY);
    }
    textInput.style.display = 'none';
  });

  // Color picker
  document.getElementById('colorPicker').addEventListener('input', (e) => {
    color = e.target.value;
    document.getElementById('colorPreview').style.backgroundColor = color;
  });

  // Brush size
  document.getElementById('brushSize').addEventListener('input', (e) => {
    brushSize = parseInt(e.target.value);
  });

  // Upload image
  document.getElementById('upload').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const img = new Image();
    img.onload = () => ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    img.src = URL.createObjectURL(file);
  });

  // Clear canvas
  function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  // Save image
  function saveImage() {
    const link = document.createElement('a');
    link.download = 'pointless-edit.png';
    link.href = canvas.toDataURL();
    link.click();
  }

  // Resize canvas and image
  function resizeCanvas() {
    const w = parseInt(document.getElementById('canvasWidth').value);
    const h = parseInt(document.getElementById('canvasHeight').value);
    const tempImage = new Image();
    tempImage.src = canvas.toDataURL();
    tempImage.onload = () => {
      canvas.width = w;
      canvas.height = h;
      ctx.drawImage(tempImage, 0, 0, w, h);
    };
  }

  // Palette generator
  function generatePalette() {
    const baseHex = document.getElementById('baseColor').value;
    const palette = getPalette(baseHex);
    const display = document.getElementById('paletteDisplay');
    display.innerHTML = '';
    palette.forEach(hex => {
      const swatch = document.createElement('div');
      swatch.className = 'swatch';
      swatch.style.background = hex;
      swatch.title = hex;
      swatch.onclick = () => {
        color = hex;
        document.getElementById('colorPicker').value = hex;
        document.getElementById('colorPreview').style.backgroundColor = hex;
      };
      display.appendChild(swatch);
    });
  }

  function getPalette(baseHex) {
    const r = parseInt(baseHex.slice(1, 3), 16);
    const g = parseInt(baseHex.slice(3, 5), 16);
    const b = parseInt(baseHex.slice(5, 7), 16);
    const comp = rgbToHex(255 - r, 255 - g, 255 - b);
    const triad1 = shiftHue(baseHex, 120);
    const triad2 = shiftHue(baseHex, 240);
    return [baseHex, comp, triad1, triad2];
  }

  function rgbToHex(r, g, b) {
    return "#" + [r, g, b].map(x => {
      const hex = x.toString(16);
      return hex.length === 1 ? "0" + hex : hex;
    }).join('');
  }

  function shiftHue(hex, degree) {
    let r = parseInt(hex.slice(1, 3), 16) / 255;
    let g = parseInt(hex.slice(3, 5), 16) / 255;
    let b = parseInt(hex.slice(5, 7), 16) / 255;
    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      let d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }

    h = (h * 360 + degree) % 360;
    if (h < 0) h += 360;
    return hslToHex(h, s, l);
  }

    function hslToHex(h, s, l) {
    h /= 360;
    let r, g, b;

    if (s === 0) {
      r = g = b = l; // achromatic
    } else {
      const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
      };

      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }

    return rgbToHex(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255));
  }

  // Paint Bucket Tool (Flood Fill)
  function floodFill(x, y, fillColor) {
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const pixels = imageData.data;
    const width = canvas.width;
    const height = canvas.height;

    const stack = [[x, y]];
    const targetColor = getPixelColor(pixels, x, y, width);
    const fill = hexToRgb(fillColor);

    if (colorsMatch(targetColor, fill)) return;

    while (stack.length) {
      const [px, py] = stack.pop();
      const currentColor = getPixelColor(pixels, px, py, width);
      if (!colorsMatch(currentColor, targetColor)) continue;

      setPixelColor(pixels, px, py, width, fill);

      stack.push([px + 1, py], [px - 1, py], [px, py + 1], [px, py - 1]);
    }

    ctx.putImageData(imageData, 0, 0);
  }

  function getPixelColor(pixels, x, y, width) {
    const i = (y * width + x) * 4;
    return [pixels[i], pixels[i + 1], pixels[i + 2]];
  }

  function setPixelColor(pixels, x, y, width, color) {
    const i = (y * width + x) * 4;
    pixels[i] = color[0];
    pixels[i + 1] = color[1];
    pixels[i + 2] = color[2];
    pixels[i + 3] = 255;
  }

  function colorsMatch(a, b) {
    return Math.abs(a[0] - b[0]) < 32 &&
           Math.abs(a[1] - b[1]) < 32 &&
           Math.abs(a[2] - b[2]) < 32;
  }

  function hexToRgb(hex) {
    return [
      parseInt(hex.slice(1, 3), 16),
      parseInt(hex.slice(3, 5), 16),
      parseInt(hex.slice(5, 7), 16)
    ];
  }
</script>
</body>
</html>
