<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Blocky Level 1 Extended</title>
  <style>
    canvas { background: #ddf; display: block; margin: 0 auto; }
    #overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.7);
      color: white;
      font-family: sans-serif;
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }
    #overlay button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 16px;
    }
  </style>
</head>
<body>
<canvas id="game" width="800" height="400"></canvas>
<div id="overlay">
  <h1>ðŸŽ‰ Level Complete!</h1>
  <p>Blocky made it to the flagpole!</p>
  <button onclick="restart()">Play Again</button>
</div>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');

let keys = {};
document.addEventListener('keydown', e => keys[e.code] = true);
document.addEventListener('keyup', e => keys[e.code] = false);

let cameraX = 0;
let levelComplete = false;

const blocky = {
  x: 100, y: 300,
  vx: 0, vy: 0,
  gravity: 0.5,
  jumpPower: -10,
  grounded: false,
  width: 20, height: 40,
  blocks: [
    { dx: 0, dy: -30 },
    { dx: -10, dy: 0 },
    { dx: 0, dy: 0 },
    { dx: 10, dy: 0 },
    { dx: -5, dy: 30 },
    { dx: 5, dy: 30 }
  ]
};

const platforms = [
  // Ground terrain
  { x: 0, y: 350, width: 3000, height: 50, color: 'red' },

  // Floating blocks and punchables
  { x: 300, y: 250, width: 40, height: 40, color: 'red' },
  { x: 350, y: 250, width: 40, height: 40, color: 'yellow', punchable: true, punched: false },
  { x: 400, y: 250, width: 40, height: 40, color: 'red' },

  // Wall jump challenge
  { x: 600, y: 300, width: 40, height: 50, color: 'red' },
  { x: 640, y: 250, width: 40, height: 100, color: 'red' },

  // Sticky zone
  { x: 1000, y: 350, width: 200, height: 50, color: 'purple', sticky: true },

  // Wind tunnel
  { x: 1300, y: 350, width: 200, height: 50, color: 'lightblue', wind: 1 },

  // Floating multi-coin block
  { x: 1600, y: 250, width: 40, height: 40, color: 'yellow', punchable: true, punched: false, multi: true }
];

const powerUps = [];
  const triangleEnemies = [
  { x: 800, y: 320, width: 20, height: 20, dir: 1 },
  { x: 1400, y: 320, width: 20, height: 20, dir: -1 }
];

const crushers = [
  { x: 1200, y: 200, width: 40, height: 40, active: false, vy: 0 }
];

const flagpole = { x: 2900, y: 200, width: 10, height: 150 };

function collide(rect1, rect2) {
  return rect1.x < rect2.x + rect2.width &&
         rect1.x + rect1.width > rect2.x &&
         rect1.y < rect2.y + rect2.height &&
         rect1.y + rect1.height > rect2.y;
}

function update() {
  if (levelComplete) return;

  blocky.vy += blocky.gravity;

  // Movement
  if (keys['ArrowRight']) blocky.vx = platforms.some(p => p.sticky && collide(blocky, p)) ? 1 : 2;
  else if (keys['ArrowLeft']) blocky.vx = platforms.some(p => p.sticky && collide(blocky, p)) ? -1 : -2;
  else blocky.vx = 0;

  // Wind tunnel
  platforms.forEach(p => {
    if (p.wind && collide(blocky, p)) {
      blocky.vx += p.wind;
    }
  });

  blocky.x += blocky.vx;
  blocky.y += blocky.vy;

  blocky.grounded = false;
  for (let plat of platforms) {
    const playerRect = {
      x: blocky.x, y: blocky.y, width: blocky.width, height: blocky.height
    };
    if (collide(playerRect, plat)) {
      if (blocky.vy > 0) {
        blocky.y = plat.y - blocky.height;
        blocky.vy = 0;
        blocky.grounded = true;
      } else if (blocky.vy < 0 && plat.punchable && !plat.punched) {
        blocky.vy = 0;
        plat.punched = true;
        const count = plat.multi ? 3 : 1;
        for (let i = 0; i < count; i++) {
          powerUps.push({ x: plat.x, y: plat.y - 20 - i * 25, width: 20, height: 20, vy: -2 });
        }
      }
    }
  }

  if (keys['Space'] && blocky.grounded) {
    blocky.vy = blocky.jumpPower;
  }

  powerUps.forEach(p => {
    p.y += p.vy;
    p.vy += 0.2;
  });

  // Triangle enemies bounce
  triangleEnemies.forEach(e => {
    e.x += e.dir * 1.5;
    if (e.x < 750 || e.x > 1450) e.dir *= -1;
    if (collide(blocky, e)) restart(); // Reset on contact
  });

  // Crushers drop
  crushers.forEach(c => {
    if (!c.active && Math.abs(blocky.x - c.x) < 40) c.active = true;
    if (c.active) {
      c.vy += 0.5;
      c.y += c.vy;
      if (collide(blocky, c)) restart();
    }
  });

  // Flagpole collision
  if (collide(blocky, flagpole)) {
    levelComplete = true;
    overlay.style.display = 'flex';
  }

  cameraX = blocky.x - canvas.width / 2;
}
function drawCharacter(baseX, baseY, time) {
  ctx.fillStyle = 'blue';
  blocky.blocks.forEach((block, i) => {
    let offsetY = block.dy;
    if (i >= 4) {
      offsetY += Math.sin(time / 200 + i) * 5;
    }
    ctx.fillRect(baseX + block.dx - cameraX, baseY + offsetY, 10, 10);
  });
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Platforms
  platforms.forEach(p => {
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - cameraX, p.y, p.width, p.height);
  });

  // Power-ups
  ctx.fillStyle = 'green';
  powerUps.forEach(p => {
    ctx.fillRect(p.x - cameraX, p.y, p.width, p.height);
  });

  // Triangle enemies
  ctx.fillStyle = 'orange';
  triangleEnemies.forEach(e => {
    ctx.beginPath();
    ctx.moveTo(e.x - cameraX, e.y + e.height);
    ctx.lineTo(e.x + e.width / 2 - cameraX, e.y);
    ctx.lineTo(e.x + e.width - cameraX, e.y + e.height);
    ctx.closePath();
    ctx.fill();
  });

  // Crushers
  ctx.fillStyle = 'black';
  crushers.forEach(c => {
    ctx.fillRect(c.x - cameraX, c.y, c.width, c.height);
  });

  // Flagpole
  ctx.fillStyle = 'black';
  ctx.fillRect(flagpole.x - cameraX, flagpole.y, flagpole.width, flagpole.height);
  ctx.fillStyle = 'white';
  ctx.fillRect(flagpole.x - cameraX + 10, flagpole.y, 20, 20); // flag

  // Character
  drawCharacter(blocky.x, blocky.y, performance.now());
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

function restart() {
  blocky.x = 100;
  blocky.y = 300;
  blocky.vx = 0;
  blocky.vy = 0;
  cameraX = 0;
  levelComplete = false;
  overlay.style.display = 'none';
  powerUps.length = 0;
  platforms.forEach(p => { if (p.punchable) p.punched = false; });
  triangleEnemies.forEach(e => { e.x = e.dir === 1 ? 800 : 1400; });
  crushers.forEach(c => { c.y = 200; c.vy = 0; c.active = false; });
}

loop();
</script>
</body>
</html>
  
